"""
In this module we will implement the functions
necessary to execute the GGH algorithm.
"""

import numpy as np


class GGHAlgorithm:
    """
    This class implements the Babai algorithm.
    It allows to cipher and decipher a message.
    """

    def __init__(
        self,
        basis: np.ndarray,
        public_key: np.ndarray | None = None,
        values_range: int = 10,
        sigma: float = 0.0001,
    ):
        if public_key is None:
            self.__generate_keys(basis, values_range=values_range)
        else:
            self.private_key = basis
            self.public_key = public_key
        self._sigma = sigma

    def cipher_message(self, m: list[int], r: np.ndarray | None = None) -> list[int]:
        """
        Ciphers a message using the public key.
        """
        m_array = np.array(m)
        print("r: ", r)
        if r is None:
            r = np.random.uniform(-self._sigma, self._sigma, size=len(m))
            print("Inside if")
        cipher_message = self.public_key @ m_array + r
        return cipher_message.tolist()

    def decipher_message(self, c: list[int]) -> list[int]:
        """
        Deciphers a message using the private key.
        """
        c_array = np.array(c)
        inv_w = np.linalg.inv(self.public_key)
        inv_b = np.linalg.inv(self.private_key)
        integer_rounded = np.round(inv_b @ c_array)
        original_message = inv_w @ self.private_key @ integer_rounded
        return np.round(original_message).astype(int).tolist()

    def __generate_keys(self, basis: np.ndarray, values_range: int):
        """
        Generates the private and public keys of the algorithm
        based on the defined basis.
        """
        self.private_key = basis
        n_dimensions = self.private_key.shape[0]
        aux_matrix = np.random.randint(
            -values_range, values_range + 1, size=(n_dimensions, n_dimensions)
        )
        while abs(np.linalg.det(aux_matrix)) != 1:
            aux_matrix = np.random.randint(
                -values_range, values_range + 1, size=(n_dimensions, n_dimensions)
            )
        u_matrix = aux_matrix.copy()
        self.public_key = self.private_key @ u_matrix

    @staticmethod
    def compute_reticle_determinant(basis: np.ndarray) -> float:
        """
        Computes the determinant associated to
        the reticle generated by the basis.
        """
        return np.sqrt(np.linalg.det(basis.T @ basis))

    @staticmethod
    def compute_delta_basis(basis: np.ndarray) -> float:
        """
        Computes the value of Delta(basis)
        to check if is a good basis.
        """
        total_numerator = 1
        for b in basis.T:
            total_numerator *= np.linalg.norm(b)
        return total_numerator / GGHAlgorithm.compute_reticle_determinant(basis=basis)
